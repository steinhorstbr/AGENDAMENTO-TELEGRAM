import TelegramBot from 'node-telegram-bot-api'
import cron from 'node-cron'
import Database from 'better-sqlite3'
import { join } from 'path'

const TELEGRAM_BOT_TOKEN = process.env.TELEGRAM_BOT_TOKEN || "6307490274:AAGx5q-tQAP-HeAUGbAOo4XVJSlbtLCkpEA"
const TELEGRAM_CHAT_ID = process.env.TELEGRAM_CHAT_ID || "-4505537919"

class TelegramService {
  private bot: TelegramBot
  private db: Database.Database
  private notificationsSent: Set<string> = new Set()

  constructor() {
    this.bot = new TelegramBot(TELEGRAM_BOT_TOKEN, { polling: true })
    
    // Inicializar banco de dados
    const dbPath = join(process.cwd(), 'data', 'schedule.db')
    this.db = new Database(dbPath)
    
    this.setupCronJobs()
    this.setupBotCommands()
  }

  private setupBotCommands() {
    // Comandos do bot
    this.bot.onText(/\/reagendar (\w{4}) \+(\d+)h?/, async (msg, match) => {
      if (msg.chat.id.toString() !== TELEGRAM_CHAT_ID) return
      
      const code = match![1].toUpperCase()
      const hours = parseInt(match![2])
      
      if (hours !== 1 && hours !== 2) {
        await this.bot.sendMessage(TELEGRAM_CHAT_ID, 
          `‚ùå Apenas +1h ou +2h s√£o permitidos.\n\nUso: /reagendar ${code} +1h ou /reagendar ${code} +2h`
        )
        return
      }
      
      await this.rescheduleTask(code, hours)
    })

    this.bot.onText(/\/finalizar (\w{4})/, async (msg, match) => {
      if (msg.chat.id.toString() !== TELEGRAM_CHAT_ID) return
      
      const code = match![1].toUpperCase()
      await this.completeTask(code)
    })

    // Comando de ajuda
    this.bot.onText(/\/help/, async (msg) => {
      if (msg.chat.id.toString() !== TELEGRAM_CHAT_ID) return
      
      const helpText = `ü§ñ *Comandos dispon√≠veis:*

üìÖ *Reagendar tarefa:*
/reagendar <c√≥digo> +1h
/reagendar <c√≥digo> +2h

‚úÖ *Finalizar tarefa:*
/finalizar <c√≥digo>

*Exemplo:*
/reagendar A1B2 +1h
/finalizar A1B2

‚ÑπÔ∏è Os c√≥digos das tarefas aparecem nas notifica√ß√µes.`

      await this.bot.sendMessage(TELEGRAM_CHAT_ID, helpText, { parse_mode: 'Markdown' })
    })
  }

  private async rescheduleTask(code: string, hoursToAdd: number) {
    try {
      const task = this.db.prepare('SELECT * FROM schedule_items WHERE code = ? AND is_completed = 0').get(code)
      
      if (!task) {
        await this.bot.sendMessage(TELEGRAM_CHAT_ID, 
          `‚ùå Tarefa ${code} n√£o encontrada ou j√° finalizada.`
        )
        return
      }

      // Calcular novo hor√°rio
      const [startHour, startMin] = (task as any).start.split(':').map(Number)
      const [endHour, endMin] = (task as any).end.split(':').map(Number)
      
      const newStartHour = startHour + hoursToAdd
      const newEndHour = endHour + hoursToAdd
      
      // Validar se n√£o passou da meia-noite
      if (newStartHour >= 24 || newEndHour >= 24) {
        await this.bot.sendMessage(TELEGRAM_CHAT_ID, 
          `‚ùå N√£o √© poss√≠vel reagendar ${code} - hor√°rio passaria da meia-noite.`
        )
        return
      }

      const newStart = `${newStartHour.toString().padStart(2, '0')}:${startMin.toString().padStart(2, '0')}`
      const newEnd = `${newEndHour.toString().padStart(2, '0')}:${endMin.toString().padStart(2, '0')}`
      
      // Verificar conflitos
      const conflicts = this.db.prepare('SELECT * FROM schedule_items WHERE date = ? AND id != ? AND is_completed = 0').all((task as any).date, (task as any).id)
        .filter((existing: any) => {
          return !(newEnd <= existing.start || newStart >= existing.end)
        })
      
      if (conflicts.length > 0) {
        await this.bot.sendMessage(TELEGRAM_CHAT_ID, 
          `‚ùå Conflito de hor√°rio ao reagendar ${code}. Verifique a agenda.`
        )
        return
      }

      // Atualizar no banco
      const rescheduledReason = `Reagendado via Telegram: +${hoursToAdd}h`
      this.db.prepare(`
        UPDATE schedule_items 
        SET start = ?, end = ?, rescheduled_reason = ?
        WHERE code = ?
      `).run(newStart, newEnd, rescheduledReason, code)

      await this.bot.sendMessage(TELEGRAM_CHAT_ID, 
        `‚úÖ *Tarefa reagendada com sucesso!*

üìã ${(task as any).title}
üïê Novo hor√°rio: ${newStart} - ${newEnd}
üìÖ Data: ${this.formatDate((task as any).date)}
üîÑ Reagendado: +${hoursToAdd}h

üí° Verifique o dashboard para confirmar.`, 
        { parse_mode: 'Markdown' }
      )

    } catch (error) {
      console.error('Error rescheduling task:', error)
      await this.bot.sendMessage(TELEGRAM_CHAT_ID, 
        `‚ùå Erro ao reagendar tarefa ${code}. Tente novamente.`
      )
    }
  }

  private async completeTask(code: string) {
    try {
      const task = this.db.prepare('SELECT * FROM schedule_items WHERE code = ? AND is_completed = 0').get(code)
      
      if (!task) {
        await this.bot.sendMessage(TELEGRAM_CHAT_ID, 
          `‚ùå Tarefa ${code} n√£o encontrada ou j√° finalizada.`
        )
        return
      }

      // Marcar como finalizada
      this.db.prepare('UPDATE schedule_items SET is_completed = 1 WHERE code = ?').run(code)

      await this.bot.sendMessage(TELEGRAM_CHAT_ID, 
        `‚úÖ *Tarefa finalizada!*

üìã ${(task as any).title}
üïê ${(task as any).start} - ${(task as any).end}
üìÖ ${this.formatDate((task as any).date)}

üéâ Parab√©ns! Tarefa conclu√≠da com sucesso.`, 
        { parse_mode: 'Markdown' }
      )

    } catch (error) {
      console.error('Error completing task:', error)
      await this.bot.sendMessage(TELEGRAM_CHAT_ID, 
        `‚ùå Erro ao finalizar tarefa ${code}. Tente novamente.`
      )
    }
  }

  private setupCronJobs() {
    // Alerta di√°rio √†s 7h da manh√£ (segunda a sexta)
    cron.schedule('0 7 * * 1-5', () => {
      this.sendDailySchedule()
    }, {
      timezone: "America/Sao_Paulo"
    })

    // Verificar notifica√ß√µes pr√≥ximas a cada 5 minutos
    cron.schedule('*/5 * * * *', () => {
      this.checkUpcomingTasks()
    }, {
      timezone: "America/Sao_Paulo"
    })

    console.log('üìÖ Telegram notifications scheduled')
  }

  private async sendDailySchedule() {
    try {
      const today = new Date().toISOString().split('T')[0]
      const tasks = this.db.prepare('SELECT * FROM schedule_items WHERE date = ? AND is_completed = 0 ORDER BY start').all(today)

      if (tasks.length === 0) {
        await this.bot.sendMessage(TELEGRAM_CHAT_ID, 
          `üåÖ *Bom dia!* \n\nüìÖ Hoje (${this.formatDate(today)}) n√£o h√° tarefas agendadas.\n\nTenha um √≥timo dia! ‚ú®`, 
          { parse_mode: 'Markdown' }
        )
        return
      }

      let message = `üåÖ *Bom dia!* \n\nüìÖ *Agenda de hoje (${this.formatDate(today)}):*\n\n`
      
      tasks.forEach((task: any, index: number) => {
        message += `${index + 1}. üïê *${task.start} - ${task.end}*\n`
        message += `   üìã ${task.title}\n`
        message += `   üî¢ C√≥digo: \`${task.code}\`\n`
        
        if (task.description) {
          message += `   üìù ${task.description}\n`
        }
        
        if (task.rescheduled_reason) {
          message += `   ‚ö†Ô∏è ${task.rescheduled_reason}\n`
        }
        
        if (task.googleMapsLink) {
          message += `   üìç [Ver localiza√ß√£o](${task.googleMapsLink})\n`
        }
        
        message += '\n'
      })

      message += `üí° *Comandos dispon√≠veis:*
/reagendar <c√≥digo> +1h
/finalizar <c√≥digo>

üí™ Tenha um dia produtivo!`

      await this.bot.sendMessage(TELEGRAM_CHAT_ID, message, { 
        parse_mode: 'Markdown',
        disable_web_page_preview: true 
      })

      console.log(`‚úÖ Daily schedule sent for ${today}`)
    } catch (error) {
      console.error('‚ùå Error sending daily schedule:', error)
    }
  }

  private async checkUpcomingTasks() {
    try {
      const now = new Date()
      const today = now.toISOString().split('T')[0]
      const currentTime = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}`
      
      const tasks = this.db.prepare('SELECT * FROM schedule_items WHERE date = ? AND is_completed = 0').all(today)

      for (const task of tasks as any[]) {
        const taskStart = this.parseTime(task.start)
        const currentTimeMinutes = this.parseTime(currentTime)
        
        // Enviar notifica√ß√£o 15 minutos antes
        const timeDiffMinutes = taskStart - currentTimeMinutes
        
        if (timeDiffMinutes <= 15 && timeDiffMinutes > 10) {
          const notificationKey = `${task.id}-15min`
          
          if (!this.notificationsSent.has(notificationKey)) {
            await this.sendTaskReminder(task, 15)
            this.notificationsSent.add(notificationKey)
          }
        }
        
        // Enviar notifica√ß√£o 5 minutos antes
        if (timeDiffMinutes <= 5 && timeDiffMinutes > 0) {
          const notificationKey = `${task.id}-5min`
          
          if (!this.notificationsSent.has(notificationKey)) {
            await this.sendTaskReminder(task, 5)
            this.notificationsSent.add(notificationKey)
          }
        }
        
        // Enviar notifica√ß√£o no hor√°rio
        if (timeDiffMinutes <= 0 && timeDiffMinutes > -5) {
          const notificationKey = `${task.id}-now`
          
          if (!this.notificationsSent.has(notificationKey)) {
            await this.sendTaskReminder(task, 0)
            this.notificationsSent.add(notificationKey)
          }
        }
      }
      
      // Limpar notifica√ß√µes antigas (mais de 1 dia)
      this.cleanOldNotifications()
      
    } catch (error) {
      console.error('‚ùå Error checking upcoming tasks:', error)
    }
  }

  private async sendTaskReminder(task: any, minutesBefore: number) {
    try {
      let message = ''
      
      if (minutesBefore === 15) {
        message = `‚è∞ *Lembrete: Tarefa em 15 minutos!*\n\n`
      } else if (minutesBefore === 5) {
        message = `üö® *Aten√ß√£o: Tarefa em 5 minutos!*\n\n`
      } else {
        message = `üîî *AGORA: Hora da tarefa!*\n\n`
      }
      
      message += `üïê *${task.start} - ${task.end}*\n`
      message += `üìã *${task.title}*\n`
      message += `üî¢ C√≥digo: \`${task.code}\`\n`
      
      if (task.description) {
        message += `üìù ${task.description}\n`
      }
      
      if (task.rescheduled_reason) {
        message += `‚ö†Ô∏è ${task.rescheduled_reason}\n`
      }
      
      if (task.googleMapsLink) {
        message += `\nüìç [Ver localiza√ß√£o no Maps](${task.googleMapsLink})\n`
      }
      
      message += `\nüí° *Comandos:*
/reagendar ${task.code} +1h
/finalizar ${task.code}`
      
      if (minutesBefore === 0) {
        message += '\n\nüöÄ Vamos l√°!'
      }

      await this.bot.sendMessage(TELEGRAM_CHAT_ID, message, { 
        parse_mode: 'Markdown',
        disable_web_page_preview: true 
      })

      console.log(`‚úÖ Task reminder sent: ${task.title} (${minutesBefore} min before)`)
    } catch (error) {
      console.error('‚ùå Error sending task reminder:', error)
    }
  }

  private parseTime(timeStr: string): number {
    const [hours, minutes] = timeStr.split(':').map(Number)
    return hours * 60 + minutes
  }

  private formatDate(dateStr: string): string {
    const date = new Date(dateStr + 'T12:00:00')
    return date.toLocaleDateString('pt-BR', { 
      weekday: 'long', 
      year: 'numeric', 
      month: 'long', 
      day: 'numeric' 
    })
  }

  private cleanOldNotifications() {
    const yesterday = new Date()
    yesterday.setDate(yesterday.getDate() - 1)
    const yesterdayStr = yesterday.toISOString().split('T')[0]
    
    // Remove notifica√ß√µes antigas
    for (const key of this.notificationsSent) {
      if (key.includes(yesterdayStr)) {
        this.notificationsSent.delete(key)
      }
    }
  }

  async sendTestMessage() {
    try {
      await this.bot.sendMessage(TELEGRAM_CHAT_ID, 
        `üîß *Teste de conex√£o*

Bot configurado com sucesso! ‚úÖ

üí° *Comandos dispon√≠veis:*
/reagendar <c√≥digo> +1h
/reagendar <c√≥digo> +2h  
/finalizar <c√≥digo>
/help

*Exemplo:*
/reagendar A1B2 +1h`, 
        { parse_mode: 'Markdown' }
      )
      console.log('‚úÖ Test message sent successfully')
    } catch (error) {
      console.error('‚ùå Error sending test message:', error)
    }
  }
}

export const telegramService = new TelegramService()

// Enviar mensagem de teste na inicializa√ß√£o
if (process.env.NODE_ENV !== 'development') {
  telegramService.sendTestMessage()
}